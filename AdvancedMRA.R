#
#	  AdvancedMRA.R
#     Copyright (C) 2023, 2024  Jean-Pierre BORG
#
#	  R software used to write the 2nd article about MRA : "Testing and overcoming the limitations of Modular Response Analysis".
#	  The files to download concerning figures ************   along with their URL, are indicated in the code.
# 
#     This program is free software: you can redistribute it and/or modify
#     it under the terms of the GNU General Public License as published by
#     the Free Software Foundation, either version 3 of the License, or
#     (at your option) any later version.
# 
#     This program is distributed in the hope that it will be useful,
#     but WITHOUT ANY WARRANTY; without even the implied warranty of
#     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#     GNU General Public License for more details.
# 
#     If you don't have a copy of the GNU General Public License,
#     see <https://www.gnu.org/licenses/>.
# 
#     Jean-Pierre BORG
#     University of Montpellier, France
#     Institut de Recherche en Cancérologie de Montpellier, INSERM, France
#	  Cancer Bioinformatics and Systems Biology  -- INSERM U1194
#     jean-pierre.borg@inserm.fr  or jeanpierre.borg@orange.fr

#
#	Article : "Testing and overcoming the limitations of Modular Response Analysis"
#
#	On the site "https://github.com/J-P-BORG/"
#		./MRARegress/R			The complete source code
#		./MRARegress/Data		All data files (.rda), specifically :
#								Solution_3G.rda : Exact, calculated values of 3-nodes network (pRaF, ppMEK, ppERK) connectivity coefficients, described in the article "Impact of measurement noise ..." (Thomaseth et al, 2018).
#								Solution_3L.rda : Exact, calculated values of a linear 3-nodes network connectivity coefficients, created according to (Alon 2006).
#								Solution_4G.rda : Exact, calculated values of 4-nodes network connectivity coefficients described in the article "Inferring dynamic ..." (Eduardo Sontag et al, 2004).
#								Solution_6K.rda : Exact, calculated values of 6-nodes network connectivity coefficients  "MAPK Cascade", described in the article "Untangling the wires ..." (Boris N. Kholodenko et al, PNAS 2002).
#								MatExp_10_1 to 5.rda	Data from the Dream Challenge 4 (DC4), 10 nodes networks, in "MRARegress" format.
#								MatExp_100_1 to 5.rda	Data from the Dream Challenge 4, 100 nodes networks, in "MRARegress" format.
#								Solution_10_1 to 5.rda and Solution_100_1 to 5.rda 	Exact values of these networks connectivity coefficients provided by Dream Challenge, in "MRARegress" format
#								(files called  "DREAM4_GoldStandard_InSilico_Size10_1.tsv" etc... by DC4).
#								Frank_TFxx_TAyy_z_R1 or R2.rda	: Data generated by Frank and processed (addition of noise level 0.1 -- R1 -- or 0.5 -- R2 -- times the average concentration of genes),
#								xx/yy = {30/0, 60/0, 100/0, 200/0, 30/30, 50/50, 100/100, 150/150} and z = {1,2..,5}.
#								Frank_TFxx_TAyy_z_Sol.rda	: Exact values of the calculated connectivity coefficients, corresponding to the previous networks.
#		./tests/testthat		The unit test files used to check the different code modules (coverage ratio 92%).
#		./vignettes				"MRARegress.Rmd" : MARKDOWN code used to generate the thumbnail.
#								"MRARegress.html" : the thumnail generated.


#	Prior to use this code, you have to install :
#		R version 4.3.2 (2023-10-31 ucrt) -- "Eye Holes" -  Platform: x86_64-w64-mingw32/x64 (64-bit),
#		RStudio 2023.06.0 Build 421,
#		Several modules (see list and version in "Supplementary Informations"),
#		"Cytoscape"  (version >= 3.6.1 required  -- our version is 3.10.2), installed and running,
#		"MRARegress" (version 1.0.0).


rm(list = ls())		# We have also to restart a new session to unload all the packages.
					# We can also detach every package individually by : detach(package:packagename).
					# Restart R    if necessary.

library ("MRARegress")
library ("stringr")
library ("RCy3")
library ("CVXR")				#	To use convexity
library ("upstartr")			#	To use unaccent
library ("data.table")			# 	To use fread
library ("foreach")				#	To use foreach
library ("doParallel")			#	To use doParallel
library ("ggplot2")				#	To use ggplot

vRoot		<-	"C:/Users/jean-pierre.borg/IRCM/These/Recherche/Packages/MRARegress/data/"			# Data storage directory. Replace it with your own.
vRootFig	<-	"C:/Users/jean-pierre.borg/IRCM/Publications/Art_MRA2/"								# Figures storage directory. Replace it with your own.

#
#	Figure 1
#	"Geometric interpretation of equation (4) for a 2-node network"
#
#	Nothing to do, it's just a drawing.
#


#
#	SI_Figure 1
#	"Illustration of the MRARegress method"
#

MatExp	<- matrix(c(1,1,1, 11,12,13, 21,22,23, 31,32,33), nrow=3)
R_Fig2	<- MRARegress(MatExp, Relative=FALSE)

R_Fig2$r
###		  	 Q1  Q2  Q3
###		N1 -1.0  2 -1.0
###		N2  0.5 -1  0.5
###		N3 -1.0  2 -1.0

Trash	<- DrawGraph(R_Fig2)


#
#	Figure 2
#	"Illustration of the estimation of connectivity coefficients by linear or polynomial regression"
#
#	Nothing to do, it's just a drawing.
#


#
#	Figure 3
#	"ROC curve and 'distance to diagonal'"
#
#	Nothing to do, it's just a drawing.
#


#
#	Table 1 and SI § 7.1.1
#	ANOVA study of the "3 kinases network"
#
#	3-nodes network (pRaF, ppMEK, ppERK), described in 
#	"Impact of measurement noise, experimental design, and estimation methods on Modular Response Analysis based network reconstruction".
#	Thomaseth et al (Scientific Reports, 2018)
#

#	ODE describing the network dynamics. X represents the expression levels of pRaF, ppMEK, ppERK respectively and P the parameters to modify.
F3n <- function(P,X)
	c(F1 = (25*(20*P[1]-X[1])/((20+20*P[1]-X[1])*(5+X[3]))-10*X[1]/(20+X[1])), 
	  F2 = (3*(20*P[2]-X[2])*X[1]/(20+20*P[2]-X[2])-10*X[2]/(20+X[2])), 
	  F3 = ((20*P[3]-X[3])*X[2]/(20+20*P[3]-X[3])-10*X[3]/(20+X[3])))

nbN			<-	3							# Number of nodes
Perturbs	<- c(0.2, 0.9, 0.99)			# Perturbations to apply
P0 			<- c(1, 1, 1)					# Initial value of the parameters
st 			<- c(0.1, 0.1, 0.1)				# Initial values of X. The X are calculated by successive iterations from these values.
NName		<- c("pRAF", "ppMEK", "ppERK")	# Node names

MExp_3_02_09_099 	<- MExp (nbN, Perturbs, P0, F3n, st)$Exp		# Simulation of 3 perturbations applied to each node. Network without noise.
Pert_3_02_09_099	<- MExp (nbN, Perturbs, P0, F3n, st)$Pert		# Perturbation names
Res_3_02_09_099		<- MRARegress(MExp_3_02_09_099, Pert_3_02_09_099, Relative=FALSE)

#	Two replicas are simulated.
nbReplic	<- 2							# Number of replicas
nbPert		<- length(Perturbs)				# Number of perturbations
XMesNPMoy	<- mean(abs(MExp_3_02_09_099[1, ]))		# Mean of undisturbed expressions
Sd			<- 0.01*XMesNPMoy				# Standard deviation of noise
MExp_		<- matrix(0, nrow=nbN, ncol=1)

set.seed(12345)								# For the results to be reproducible
MExp_[ ,1]	<-	MExp_3_02_09_099[ ,1]		# The 1° column (base) is separate, so as to merge the 9 perturbed columns of each replica
Pert_		<- c("Base")

for (iRep in 1:nbReplic) {
	MExp_3_2	<- MExp_3_02_09_099 + rnorm(nbN*(nbN*nbPert+1), mean=0, sd=Sd)
	MExp_		<- cbind(MExp_, MExp_3_2[ ,2:(nbPert*nbN+1)])	# We merge to the basal column, the 9 perturbed columns corresponding to each replica
	Pert_		<- c(Pert_, Pert_3_02_09_099  [2:(nbPert*nbN+1)])
}

for (iNode in 1:nbN) {
	orig	<- paste("N", iNode, sep="")
	Pert_	<- str_replace_all(Pert_, orig, NName[iNode])
}

Res_3G		<- MRARegress(MExp_, Pert_, NodeName=NName, Relative=FALSE)
#	Res_3G$ANOVA
round (Res_3G$ANOVA[[1]], 2)
###			  df/m df/M Sum/m  Sum/M  Mean/m Mean/M      F/m       F/M     pVal/m  pVal/M   nbrNdes
###		SSR     2    2 10.08   87.59   5.04  43.79    6312.53   26831.38      0     0.00       0
###		SSE    10   10  0.01    0.05   0.00   0.01       0.00       0.00      0     0.00       0
###		LOF     4    4  0.01    0.03   0.00   0.01       2.33      25.87      0     0.17       2
###		Pure    6    6  0.00    0.00   0.00   0.00       0.00       0.00      0     0.00       0
###		TSS    12   12 10.09   87.60   0.00   0.00       0.00       0.00      0     0.00       0

Res_3G		<- MRARegress(MExp_, Pert_, NodeName=NName, Relative=FALSE, Verbose=TRUE)			# To display the values for each node (S.I.)
###		SSR 
###		iNode :  1  Sum :  10.08214  F :  8084.176  pVal :  9.022537e-17  Name :  pRAF 
###		iNode :  2  Sum :  65.63805  F :  6312.529  pVal :  3.105374e-16  Name :  ppMEK 
###		iNode :  3  Sum :  87.58721  F :  26831.38  pVal :  2.245073e-19  Name :  ppERK 
###		
###		LOF 
###		iNode :  1  Sum :  0.005178548  F :  8.372081  pVal :  0.0124326  PValN  C 
###		iNode :  2  Sum :  0.03409683  F :  25.86601  pVal :  0.0006316383  PValN  C 
###		iNode :  3  Sum :  0.007573915  F :  2.326909  pVal :  0.1700639  PValN  D 

ficSol	<- paste (vRoot, "Solution_3G.rda", sep="")
load (ficSol)
print (round(Solution_3G,2))																					# 	Exact Connectivity Matrix
###		      [,1]  [,2]  [,3]
###		[1,] -1.00  0.00 -0.18
###		[2,]  3.02 -1.00  0.00
###		[3,]  0.00  0.98 -1.00

print (round(Res_3_02_09_099$r,2))																				#	Approximate Connectivity Matrix  (using order 1)
###		   	  Q1a;Q1b;Q1c    Q2a;Q2b;Q2c   Q3a;Q3b;Q3c
###		N1      -1.00         0.00         -0.31
###		N2       2.85        -1.00          0.11
###		N3      -0.01         1.07         -1.00

ResO2_3_02_09_099	<- MRARegress(MExp_3_02_09_099, Pert_3_02_09_099, Relative=FALSE, Method="Order2")			#	Approximate Connectivity Matrix  (using order 2)
print (round(ResO2_3_02_09_099$r,2))
###		      Q1a;Q1b;Q1c    Q2a;Q2b;Q2c   Q3a;Q3b;Q3c
###		N1      -1.00          0.00          -0.18
###		N2       3.03         -1.00           0.00
###		N3       0.01          0.98          -1.00

MatDif	<-	matrix (0, nrow=2, ncol=nbN*nbN)
MatDif[1, ]		<- Solution_3G

MatDif[2, ]		<- Res_3_02_09_099$r
D_3G	<-	dist(MatDif)
###		0.2535509						Euclidian distance between 'Exact Connectivity' and 'Approximate Connectivity (Order 1)' matrices

MatDif[2, ]		<- ResO2_3_02_09_099$r
DO2_3G	<-	dist(MatDif)
###		0.00876365						Euclidian distance between 'Exact Connectivity' and 'Approximate Connectivity (Order 2)' matrices

print (round(Res_3G$r,3))																	#	Approximate Connectivity Matrix  (using order 1 and 2 replicas) -- used by Fig 5a
###		   	  	Q1a;Q1b;Q1c    Q2a;Q2b;Q2c   Q3a;Q3b;Q3c
###		pRAF      -1.000          0.001        -0.311
###		ppMEK      2.873         -1.000         0.106
###		ppERK      0.020          1.065        -1.000
		

#
#	Table 2 and SI § 7.1.2
#	ANOVA study of the "'Linear' 3 genes network"
#	created from the book "An Introduction to Systems Biology: Design Principles of Biological Circuits",
#	Alon (Chapman and Hall/CRC, 2006)
#

# 	Protein production rate :
a1	= 0.5 			# (unit of concentration per unit of time)
a2	= 0.4
a3	= 0.3

#	Protein degradation rate :
b1	= 0.1 			# (inverse time unit : 1/t)
b2	= 0.2
b3	= 0.15

#	Rate of repression between genes :
c12	= 0.05			#  (for repression of x2 by x1)
c13	= 0.03
c21	= 0.04
c23	= 0.02
c31	= 0.06
c32	= 0.07

#	ODE describing the network dynamics. X represents the expression levels of N1, N2 and N3 respectively and P the parameters to modify.
F3Ln	<- function(P,X)
	c(F1 = (a1*P[1] -  b1*X[1] - c12*X[2] - c13*X[3]),
	  F2 = (a2*P[2] - c21*X[1] -  b2*X[2] - c23*X[3]),
	  F3 = (a3*P[3] - c31*X[1] - c32*X[2] -  b3*X[3]))
	  
nbN			<-	3							# Number of nodes
Perturbs	<- c(0.2, 0.9, 0.99)			# Perturbations to apply
P0 			<- c(1, 1, 1)					# Initial value of the parameters
st 			<- c(0.1, 0.1, 0.1)				# Initial values of X. The X are calculated by successive iterations from these values.

MExp_3L_02_09_099 	<- MExp (nbN, Perturbs, P0, F3Ln, st)$Exp		# Simulation of 3 'linear' perturbations applied to each node. Network without noise.
Pert_3L_02_09_099	<- MExp (nbN, Perturbs, P0, F3Ln, st)$Pert		# Perturbation names

#	Two replicas are simulated.
nbReplic	<- 2							# Number of replicas
nbPert		<- length(Perturbs)				# Number of perturbations
XMesNPMoy	<- mean(abs(MExp_3L_02_09_099[1, ]))		# Mean of undisturbed expressions
Sd			<- 0.01*XMesNPMoy				# Standard deviation of noise
MExp_		<- matrix(0, nrow=nbN, ncol=1)
Pert_		<- c("Base")

set.seed(12345)								# For the results to be reproducible
MExp_[ ,1]	<-	MExp_3L_02_09_099[ ,1]		# The 1° column (base) is separate, so as to merge the 9 perturbed columns of each replica

for (iRep in 1:nbReplic) {
	MExp_3_2	<- MExp_3L_02_09_099 + rnorm(nbN*(nbN*nbPert+1), mean=0, sd=Sd)
	MExp_		<- cbind(MExp_, MExp_3_2[ ,2:(nbPert*nbN+1)])
	Pert_		<- c(Pert_, Pert_3L_02_09_099  [2:(nbPert*nbN+1)])
}

Res_3L		<- MRARegress(MExp_, Pert_, Relative=FALSE)
#	Res_3L$ANOVA
round (Res_3L$ANOVA[[1]], 2)
###			  df/m  df/M  Sum/m  Sum/M Mean/m   Mean/M     F/m      F/M     pVal/m  pVal/M  nbrNdes
###		SSR     2    2    1.46   5.51   0.73     2.76   485.54   1629.26    0.00      0       0
###		SSE    10   10    0.01   0.02   0.00     0.00     0.00      0.00    0.00      0       0
###		LOF     4    4    0.00   0.01   0.00     0.00     0.04      3.94    0.07      1       0
###		Pure    6    6    0.00   0.02   0.00     0.00     0.00      0.00    0.00      0       0
###		TSS    12   12    1.47   5.53   0.00     0.00     0.00      0.00    0.00      0       0
															    
Res_3L		<- MRARegress(MExp_, Pert_, Relative=FALSE, Verbose=TRUE)							# To display the values for each node (S.I.)
###		SSR 
###		iNode :  1  Sum :  1.647895  F :  673.9194  pVal :  2.1665e-11  Name :  N1 
###		iNode :  2  Sum :  1.456835  F :  485.5358  pVal :  1.100263e-10  Name :  N2 
###		iNode :  3  Sum :  5.511326  F :  1629.259  pVal :  2.680687e-13  Name :  N3 
###		
###		LOF 
###		iNode :  1  Sum :  0.007875321  F :  3.941128  pVal :  0.06647714  PValN  D 
###		iNode :  2  Sum :  0.00846698  F :  1.98825  pVal :  0.215483  PValN  D 
###		iNode :  3  Sum :  0.0003706  F :  0.03524449  pVal :  0.9969338  PValN  D 

ficSol	<- paste (vRoot, "Solution_3L.rda", sep="")
load (ficSol)
print (round(Solution_3L,2))																					# 	Exact Connectivity Matrix
###		      [,1] [,2] [,3]
###		[1,] -1.0 -0.50 -0.3
###		[2,] -0.2 -1.00 -0.1
###		[3,] -0.4 -0.47 -1.0

print (round(Res_3L$r,2))																						#	Approximate Connectivity Matrix  (using order 1 and 2 replicas)
###				Q1a;Q1b;Q1c;Q1a;Q1b;Q1c 	Q2a;Q2b;Q2c;Q2a;Q2b;Q2c 	Q3a;Q3b;Q3c;Q3a;Q3b;Q3c
###		N1             -1.00                       -0.50                       -0.30
###		N2             -0.21                       -1.00                       -0.11
###		N3             -0.40                       -0.47                       -1.00

print (round(Res_3L$r,3))																	#	Approximate Connectivity Matrix  (using order 1 and 2 replicas) -- used by Fig 5b
###				Q1a;Q1b;Q1c;Q1a;Q1b;Q1c 	Q2a;Q2b;Q2c;Q2a;Q2b;Q2c 	Q3a;Q3b;Q3c;Q3a;Q3b;Q3c
###		N1             -1.000                      -0.498                      -0.296
###		N2             -0.208                      -1.000                      -0.111
###		N3             -0.400                      -0.474                      -1.000


#
#	SI § 7.1.3
#	"4 nodes network"
#	"Inferring dynamic architecture of cellular networks using time series of gene expression, protein and metabolite data"
#	E. Sontag (Bioinforma. Oxf. Engl. 2004)

# Constants related to reaction kinetics	
KA14 <- 1.6			# Michaelis constants in nM
KI12 <- 0.5
KA24 <- 1.6
KA32 <- 1.5
KI31 <- 0.7
KA43 <- 0.15
KD1	 <- 30
KD2	 <- 60
KD3	 <- 10
KD4	 <- 50

A14	 <- 4			# Dimensionless Coeff.
n12	 <- 1
n14	 <- 2
A24	 <- 4
n24	 <- 2
A32	 <- 5
n31	 <- 1
n32	 <- 2
A43	 <- 2
n43	 <- 2

VS1	 <- 1			# Maximum enzyme rate in nM.Hr-1
VS2	 <- 0.7
VS3	 <- 0.6
VS4	 <- 0.8
VD1	 <- 40
VD2	 <- 100
VD3	 <- 30
VD4	 <- 100

#	ODE describing the network dynamics. X represents the expression levels of the genes respectively and P the parameters to modify.
F4n <- function(P,X)
   c(F1 = (P[1]*(1+A14*(X[4]/KA14)^n14)) / ((1+(X[4]/KA14)^n14)*(1+(X[2]/KI12)^n12)) - (VD1*X[1]) / (KD1+X[1]),
	 F2 = (P[2]*(1+A24*(X[4]/KA24)^n24)) /  (1+(X[4]/KA24)^n24) - (VD2*X[2]) / (KD2+X[2]),
	 F3 = (P[3]*(1+A32*(X[2]/KA32)^n32)) / ((1+(X[2]/KA32)^n32)*(1+(X[1]/KI31)^n31)) - (VD3*X[3]) / (KD3+X[3]),
	 F4 = (P[4]*(1+A43*(X[3]/KA43)^n43)) /  (1+(X[3]/KA43)^n43) - (VD4*X[4]) / (KD4+X[4]))

nbN		 	<- 4
Perturbs 	<- c(0.2, 0.9, 0.99)
P0		 	<- c(VS1, VS2, VS3, VS4)	
st 		 	<- c(0.1, 0.1, 0.1, 0.1)

MExp_4_02_09_099 	<- MExp (nbN, Perturbs, P0, F4n, st)$Exp			# Simulation of 3 perturbations applied to each node. Network without noise.
Pert_4_02_09_099 	<- MExp (nbN, Perturbs, P0, F4n, st)$Pert			# Perturbation names
Res_4_02_09_099		<- MRARegress(MExp_4_02_09_099, Pert_4_02_09_099, Relative=FALSE)

#	Two replicas are simulated.
nbReplic	<- 2							# Number of replicas
nbPert		<- length(Perturbs)				# Number of perturbations
XMesNPMoy	<- mean(abs(MExp_4_02_09_099[1, ]))		# Mean of undisturbed expressions
Sd			<- 0.01*XMesNPMoy				# Standard deviation of noise
MExp_		<- matrix(0, nrow=nbN, ncol=1)

set.seed(12345)								# For the results to be reproducible
MExp_[ ,1]	<-	MExp_4_02_09_099[ ,1]		# The 1° column (base) is separate, so as to merge the perturbed columns of each replica
Pert_		<- c("Base")

for (iRep in 1:nbReplic) {
	MExp_4_2	<- MExp_4_02_09_099 + rnorm(nbN*(nbN*nbPert+1), mean=0, sd=Sd)
	MExp_		<- cbind(MExp_, MExp_4_2[ ,2:(nbPert*nbN+1)])	# We merge to the basal column, the 12 perturbed columns corresponding to each replica
	Pert_		<- c(Pert_, Pert_4_02_09_099  [2:(nbPert*nbN+1)])
}

Res_4G		<- MRARegress(MExp_, Pert_, Relative=FALSE)
#	Res_4G$ANOVA
round (Res_4G$ANOVA[[1]], 2)
###		      df/m df/M Sum/m Sum/M Mean/m Mean/M    F/m      F/M     pVal/m   pVal/M  nbrNdes
###		SSR     3    3  0.04  0.22   0.01   0.07   485.22    970.82      0     0.00       0
###		SSE    15   15  0.00  0.00   0.00   0.00     0.00      0.00      0     0.00       0
###		LOF     6    6  0.00  0.00   0.00   0.00     2.01      9.60      0     0.17       2
###		Pure    9    9  0.00  0.00   0.00   0.00     0.00      0.00      0     0.00       0
###		TSS    18   18  0.04  0.22   0.00   0.00     0.00      0.00      0     0.00       0

Res_4G		<- MRARegress(MExp_, Pert_, Relative=FALSE, Verbose=TRUE)							# To display the values for each node
###		SSR 
###		iNode :  1  Sum :  0.2235415  F :  970.8151  pVal :  2.146921e-17  Name :  N1 
###		iNode :  2  Sum :  0.08811518  F :  511.1987  pVal :  2.541357e-15  Name :  N2 
###		iNode :  3  Sum :  0.04260785  F :  485.2189  pVal :  3.742551e-15  Name :  N3 
###		iNode :  4  Sum :  0.1382237  F :  499.6679  pVal :  3.01028e-15  Name :  N4 
###		
###		LOF 
###		iNode :  1  Sum :  0.0009105927  F :  9.583765  pVal :  0.001745276  PValN  C 
###		iNode :  2  Sum :  0.0004962563  F :  2.95187  pVal :  0.07050618  PValN  D 
###		iNode :  3  Sum :  0.0002651785  F :  2.013253  pVal :  0.1659392  PValN  D 
###		iNode :  4  Sum :  0.0009967256  F :  9.598697  pVal :  0.001735313  PValN  C 

ficSol	<- paste (vRoot, "Solution_4G.rda", sep="")
load (ficSol)
print (round(Solution_4G,2))																					# 	Exact Connectivity Matrix
###		Q1a   Q2a   Q3a   Q4a
###		N1 -1.00 -0.45  0.00  0.39
###		N2  0.00 -1.00  0.00  0.48
###		N3 -0.16  0.19 -1.00  0.00
###		N4  0.00  0.00  1.05 -1.00

print (round(Res_4_02_09_099$r,2))																				#	Approximate Connectivity Matrix  (using order 1)
###			  Q1a;Q1b;Q1c 	Q2a;Q2b;Q2c   Q3a;Q3b;Q3c   Q4a;Q4b;Q4c
###		N1      -1.00         -0.78          0.17          0.40
###		N2       0.01         -1.00          0.16          0.33
###		N3      -0.25          0.00         -1.00          0.07
###		N4       0.18          0.13          1.36         -1.00

ResO2_4_02_09_099	<- MRARegress(MExp_4_02_09_099, Pert_4_02_09_099, Relative=FALSE, Method="Order2")			#	Approximate Connectivity Matrix  (using order 2)
print (round(ResO2_4_02_09_099$r,2))
###			  Q1a;Q1b;Q1c 	Q2a;Q2b;Q2c   Q3a;Q3b;Q3c   Q4a;Q4b;Q4c
###		N1      -1.00         -0.45          0.00          0.39
###		N2       0.00         -1.00          0.00          0.48
###		N3      -0.16          0.19         -1.00          0.00
###		N4       0.00          0.00          1.05         -1.00

MatDif	<-	matrix (0, nrow=2, ncol=nbN*nbN)
MatDif[1, ]		<- Solution_4G

MatDif[2, ]		<- Res_4_02_09_099$r
D_4G	<-	dist(MatDif)
###		0.6169653						Euclidian distance between 'Exact Connectivity' and 'Approximate Connectivity (Order 1)' matrices

MatDif[2, ]		<- ResO2_4_02_09_099$r
DO2_4G	<-	dist(MatDif)
###		0.002214955						Euclidian distance between 'Exact Connectivity' and 'Approximate Connectivity (Order 2)' matrices

print (round(Res_4G$r,3))																	#	Approximate Connectivity Matrix  (using order 1 and 2 replicas) -- used by Fig 5c
###				Q1a;Q1b;Q1c;Q1a;Q1b;Q1c 	Q2a;Q2b;Q2c;Q2a;Q2b;Q2c 	Q3a;Q3b;Q3c;Q3a;Q3b;Q3c 	Q4a;Q4b;Q4c;Q4a;Q4b;Q4c
###		N1            -1.000                       -0.769                        0.194                        0.398
###		N2             0.017                       -1.000                        0.177                        0.330
###		N3            -0.273                       -0.011                       -1.000                        0.076
###		N4             0.206                        0.143                        1.289                       -1.000


#
#	SI § 7.1.4
#	""MAPK Cascade" : 6 nodes network
#	"Untangling the wires: a strategy to trace functional interactions in signaling and gene networks".
#	Boris N. Kholodenko et al, PNAS 2002.

# Constants related to reaction kinetics
KC1	 <- 1			# Catalytic ratios in s-1
KC2	 <- 15
KC5	 <- 1
KC6	 <- 15
KC9	 <- 1
KC10 <- 15

K11	 <- 300			# Michaelis constants in nM
K12	 <- 20
K31	 <- 22
K32	 <- 18
K33	 <- 80
K51	 <- 300
K52	 <- 20
K71	 <- 22
K72	 <- 18
K73	 <- 80
K91	 <- 300
K92	 <- 20
K111 <- 22
K112 <- 18
K113 <- 80
Ki	 <- 100
Kmp	 <- 100

A	 <- 5			# Dimensioless coeff.

V3	 <- 18.8		# Maximum enzyme level in nM.s-1
V4	 <- 16.4
V7	 <- 18.8
V8	 <- 16.4
V11	 <- 8.4
V12	 <- 7.3

MKKK0	<- 200		# X1+X7+X2	: total concentration of MKKK protein
MKK0	<- 180		# X3+X8+X4	: total concentration of MKK protein
MAPK0	<- 360		# X5+X9+X6	: total concentration of MAPK protein
U	<- 20

#	ODE describing the network dynamics. X represents the expression levels of pRaF, ppMEK, ppERK respectively and P the parameters to modify.
F6n 	<- function(P,X)
   c(F1 = (KC1*U*X[1]) 	/ ((K11+X[1]+(MKKK0-X[1]-X[2])*K11/K12)*(1+X[6]/Ki)) - ((P[1]*(MKKK0-X[1]-X[2]))  / (K31+X[2]+(MKKK0-X[1]-X[2])*K31/K32+X[1]*K31/K33)),
	 F2 = (KC2*U*(MKKK0-X[1]-X[2]))    / ((K11+X[1]+(MKKK0-X[1]-X[2])*K11/K12)*(1+X[6]/Ki)) - ((P[2]*X[2])  / (K31+X[2]+(MKKK0-X[1]-X[2])*K31/K32+X[1]*K31/K33)),
	 F3 = (KC5*X[3]*X[2]) / (K51+X[3]+(MKK0-X[3]-X[4])*K51/K52) - ((P[3]*(MKK0-X[3]-X[4])*(1+A*X[6]/Kmp))   / ((K71+X[4]+(MKK0-X[3]-X[4])*K71/K72+X[3]*K71/K73)*(1+X[6]/Kmp))),
	 F4 = (KC6*(MKK0-X[3]-X[4])*X[2])  / (K51+X[3]+(MKK0-X[3]-X[4])*K51/K52) - ((P[4]*X[4]*(1+A*X[6]/Kmp))  / ((K71+X[4]+(MKK0-X[3]-X[4])*K71/K72+X[3]*K71/K73)*(1+X[6]/Kmp))),
	 F5 = (KC9*X[4]*X[5]) / (K91+X[5]+(MAPK0-X[5]-X[6])*K91/K92) - ((P[5]*(MAPK0-X[5]-X[6])) / (K111+X[6]+(MAPK0-X[5]-X[6])*K111/K112+X[5]*K111/K113)),
	 F6 = (KC10*X[4]*(MAPK0-X[5]-X[6]))/ (K91+X[5]*(MAPK0-X[5]-X[6])*K91/K92) - ((P[6]*X[6]) / (K111+X[6]+(MAPK0-X[5]-X[6])*K111/K112+X[5]*K111/K113)))

nbN			<-	6							# Number of nodes
st			<- c(130,45,52,105,135,27)		# Initial value of the parameters : Multiroot finds the solutions this time
Perturbs	<- c(0.2, 0.5, 0.9, 0.99, 1.5)	# Perturbations to apply
P0			<- c(V4, V3, V8, V7, V12, V11)	# The disturbed parameters are V4, V3, V8, V7, V12, V11
NName		<- c("MKKK", "ppMKKK", "MKK", "ppMKK", "MAPK", "ppMAPK")		# Node names

MExp_6_02_05_09_099_15 	<- MExp (nbN, Perturbs, P0, F6n, st)$Exp			# Simulation of 5 perturbations applied to each node. Network without noise.
Pert_6_02_05_09_099_15 	<- MExp (nbN, Perturbs, P0, F6n, st)$Pert			# Perturbation names
Res_6_02_05_09_099_15	<- MRARegress(MExp_6_02_05_09_099_15, Pert_6_02_05_09_099_15, Relative=FALSE)

#	Two replicas are simulated.
nbReplic	<- 2							# Number of replicas
nbPert		<- length(Perturbs)				# Number of perturbations
XMesNPMoy	<- mean(abs(MExp_6_02_05_09_099_15[1, ]))		# Mean of undisturbed expressions
Sd			<- 0.01*XMesNPMoy				# Standard deviation of noise

MExp_		<- matrix(0, nrow=nbN, ncol=1)

set.seed(12345)								# For the results to be reproducible
MExp_[ ,1]	<-	MExp_6_02_05_09_099_15[ ,1]	# The 1° column (base) is separate, so as to merge the 30 perturbed columns of each replica
Pert_		<- c("Base")

for (iRep in 1:nbReplic) {
	MExp_6_2	<- MExp_6_02_05_09_099_15 + rnorm(nbN*(nbN*nbPert+1), mean=0, sd=Sd)
	MExp_		<- cbind(MExp_, MExp_6_2[ ,2:(nbPert*nbN+1)])	# We merge to the basal column, the 30 perturbed columns corresponding to each replica
	Pert_		<- c(Pert_, Pert_6_02_05_09_099_15  [2:(nbPert*nbN+1)])
}

for (iNode in 1:nbN) {
	orig	<- paste("N", iNode, sep="")
	Pert_	<- str_replace_all(Pert_, orig, NName[iNode])
}

Res_6K		<- MRARegress(MExp_, Pert_, NodeName=NName, Relative=FALSE)
#	Res_6K$ANOVA
round (Res_6K$ANOVA[[1]], 2)
###		      df/m df/M   Sum/m      Sum/M    Mean/m    Mean/M    F/m       F/M     pVal/m  pVal/M   nbrNdes
###		SSR     5    5   4165.21   29528.79   833.04   5905.76   310.77   1192.29      0     0.00       0
###		SSE    45   45    113.01     535.02     2.51     11.89     0.00      0.00      0     0.00       0
###		LOF    20   20     43.67     436.48     2.18     21.82     0.97      9.78      0     0.52       5
###		Pure   25   25     33.05      56.00     1.32      2.24     0.00      0.00      0     0.00       0
###		TSS    50   50   4278.22   29833.98     0.00      0.00     0.00      0.00      0     0.00       0
 
Res_6K		<- MRARegress(MExp_, Pert_, NodeName=NName, Relative=FALSE, Verbose=TRUE)			# To display the values for each node
###		SSR 
###		iNode :  1  Sum :  21452.08  F :  1129.298  pVal :  4.360595e-46  Name :  MKKK 
###		iNode :  2  Sum :  4165.208  F :  331.7099  pVal :  2.599626e-34  Name :  ppMKKK 
###		iNode :  3  Sum :  27258.43  F :  1192.288  pVal :  1.29869e-46  Name :  MKK 
###		iNode :  4  Sum :  29528.79  F :  870.8145  pVal :  1.429038e-43  Name :  ppMKK 
###		iNode :  5  Sum :  28960.16  F :  1077.923  pVal :  1.231952e-45  Name :  MAPK 
###		iNode :  6  Sum :  18474.49  F :  310.7742  pVal :  1.080147e-33  Name :  ppMAPK 
###		
###		LOF 
###		iNode :  1  Sum :  75.92562  F :  2.379376  pVal :  0.02079516  PValN  C 
###		iNode :  2  Sum :  43.67301  F :  0.974867  pVal :  0.5173438  PValN  D 
###		iNode :  3  Sum :  123.7814  F :  4.22781  pVal :  0.0004384207  PValN  C 
###		iNode :  4  Sum :  222.7742  F :  8.42616  pVal :  9.505779e-07  PValN  C 
###		iNode :  5  Sum :  191.4479  F :  6.445572  pVal :  1.211509e-05  PValN  C 
###		iNode :  6  Sum :  436.4825  F :  9.777496  pVal :  2.149944e-07  PValN  C 

ficSol	<- paste (vRoot, "Solution_6K.rda", sep="")
load (ficSol)
print (round(Solution_6K,2))																					# 	Exact Connectivity Matrix
###		     Q1a   Q2a   Q3a   Q4a   Q5a   Q6a
###		N1 -1.00 -0.99  0.00  0.00  0.00  0.12
###		N2 -0.71 -1.00  0.00  0.00  0.00 -0.16
###		N3  0.00 -0.26 -1.00 -0.85  0.00  0.16
###		N4  0.00  0.59 -0.89 -1.00  0.00 -0.35
###		N5  0.00  0.00  0.00 -0.71 -1.00 -0.66
###		N6  0.00  0.00  0.00  0.27 -0.28 -1.00

print (round(Res_6_02_05_09_099_15$r,2))																		#	Approximate Connectivity Matrix  (using order 1)
###		 		Q1a;Q1b;Q1c;Q1d;Q1e 	Q2a;Q2b;Q2c;Q2d;Q2e 	Q3a;Q3b;Q3c;Q3d;Q3e 	Q4a;Q4b;Q4c;Q4d;Q4e 	Q5a;Q5b;Q5c;Q5d;Q5e 	Q6a;Q6b;Q6c;Q6d;Q6e
###		N1          -1.00                   -0.97                    0.00                   -0.01                    0.00                    0.12
###		N2          -0.64                   -1.00                    0.02                    0.03                    0.00                   -0.16
###		N3           0.05                   -0.06                   -1.00                   -0.92                    0.01                    0.24
###		N4          -0.17                    0.29                   -0.85                   -1.00                    0.00                   -0.33
###		N5           0.02                    0.05                    0.10                   -0.75                   -1.00                   -0.30
###		N6           0.25                    0.44                    0.26                    0.58                   -0.36                   -1.00

ResO2_6_02_05_09_099_15	<- MRARegress(MExp_6_02_05_09_099_15, Pert_6_02_05_09_099_15, Relative=FALSE, Method="Order2")	#	Approximate Connectivity Matrix  (using order 2)
print (round(ResO2_6_02_05_09_099_15$r,2))
###		 		Q1a;Q1b;Q1c;Q1d;Q1e 	Q2a;Q2b;Q2c;Q2d;Q2e 	Q3a;Q3b;Q3c;Q3d;Q3e 	Q4a;Q4b;Q4c;Q4d;Q4e 	Q5a;Q5b;Q5c;Q5d;Q5e 	Q6a;Q6b;Q6c;Q6d;Q6e
###		N1          -1.00                   -0.99                    0.00                    0.00                    0.00                    0.12
###		N2          -0.71                   -1.00                    0.00                    0.00                    0.00                   -0.16
###		N3           0.00                   -0.27                   -1.00                   -0.85                    0.00                    0.16
###		N4           0.02                    0.61                   -0.89                   -1.00                    0.00                   -0.35
###		N5           0.00                    0.00                    0.00                   -0.71                   -1.00                   -0.66
###		N6           0.01                    0.01                    0.00                    0.27                   -0.28                   -1.00

MatDif	<-	matrix (0, nrow=2, ncol=nbN*nbN)
MatDif[1, ]		<- Solution_6K

MatDif[2, ]		<- Res_6_02_05_09_099_15$r
D_6K	<-	dist(MatDif)
###		0.8711854						Euclidian distance between 'Exact Connectivity' and 'Approximate Connectivity (Order 1)' matrices

MatDif[2, ]		<- ResO2_6_02_05_09_099_15$r
DO2_6K	<-	dist(MatDif)
###		0.03618133						Euclidian distance between 'Exact Connectivity' and 'Approximate Connectivity (Order 2)' matrices

print (round(Res_6K$r,3))																	#	Approximate Connectivity Matrix  (using order 1 and 2 replicas) -- used by Fig 5c
###		      		Q1a; ...;Q1e 	Q2a; ...;Q2e	Q3a; ...;Q3e	Q4a; ...;Q4e	Q5a; ...;Q5e	Q6a; ...;Q6e
###		MKKK          -1.000           -0.966		    0.010			0.002		   -0.024			0.097
###		ppMKKK        -0.646           -1.000           0.017           0.029          -0.020          -0.167
###		MKK            0.046           -0.101          -1.000          -0.928           0.025           0.304
###		ppMKK         -0.202            0.203          -0.846          -1.000           0.011          -0.245
###		MAPK           0.045            0.055           0.098          -0.739          -1.000          -0.279
###		ppMAPK         0.217            0.433           0.199           0.522          -0.347          -1.000


#
#	Figure 4
#	"Illustration of non-linearity highlighted by MRARegress"
#

#	The figures drawn in the article correspond to the approximate connectivity coefficients, discovered by MRARegress using a linear regression in order 1 ('TLR' method),
#	using the indicated perturbations (-80%, -10% and -1% for 3- or 4-node networks and -80%, -50%, -10%, -1% and +50% for the MAPK cascade) and two replicas.
#	- no replica for fig 5a, 5c, 5d
#	- two replicas for fig 5b (see S.I.).

#	Figure 4a	: 3 kinases network (Thomaseth et al, 2018)						-- Run the code for Table 1 first
Trash	<-	DrawGraph (Res_3G)			
						# In 'Cytoscape',  File > Export > Network to Image  (you can choose .png format or .svg format and with 'Inkscape', export the image as a .png file, 600 ppp

#	Figure 4b	: Linear 3 genes network (Alon, 2006)							-- Run the code for Table 2 first
Trash	<-	DrawGraph (Res_3L)

#	Figure 4c	: 4 genes network (Eduardo Sontag et al, 2004)					-- Run the code for SI § 7.1.3 first
Trash	<-	DrawGraph (Res_4G)

#	Figure 4d	: MAPK cascade: 6 nodes network (B. N. Kholodenko et al, 2002)	-- Run the code for SI § 7.1.4 first
Trash	<-	DrawGraph (Res_6K)


#
#	Table 3
#	Euclidian distance between 'Exact Connectivity' and 'Approximate Connectivity)' matrices  -- non noisy measures
#

#	Three kinases
print (round(D_3G, 3))			#	Distance (Order 1 : linear MRA)
###		0.2535509
print (round(DO2_3G, 3))		#	Distance (Order 2 : 2nd degree MRA)
###		0.00876365

#	Four nodes
print (round(D_4G, 3))			#	Distance (Order 1: Linear MRA)
###		0.6169653
print (round(DO2_4G, 3))		#	Distance (Order 2 : 2nd degree MRA)
###		0.002214955

#	MAPK Cascade (6 nodes)
print (round(D_6K, 3))			#	Distance (Order 1 : Linear MRA)
###		0.8711854
print (round(DO2_6K, 3))		#	Distance (Order 2 : 2nd degree MRA)
###		0.03618133


#
#	Table 4
#	Euclidian distance between 'Exact Connectivity' and 'Approximate Connectivity)' matrices, according to noise
#

distMeasures <- function (MatExp, Pert, Sol, nbN, nbRep, nbPert, Levels, nbTrials) {
#	MatExp		Value of expression levels without noise	(non perturbed -- 1st column, and perturbed nodes -- following columns)
#	Pert		Perturbation names
#	Sol			Exact connectivity matrix
#	nbN			Number of nodes of the network
#	nbRep		Number of replicas
#	nbPert		Number of perturbations
#	Levels		Variation coefficients
#	nbTrials	Number of trials to do
#
#	This function returns an array ('Dists' : 2 rows, nbTrials columns, nbr of levels)
#		1st row		: Euclidian distance between 'Exact Connectivity' and 'Approximate Connectivity (Order 1)' matrices for each trial
#		2nd row		: Euclidian distance between 'Exact Connectivity' and 'Approximate Connectivity (Order 2)' matrices for each trial

	XMesNPMoy	<- mean(abs(MatExp[1, ]))				# Mean of non perturbed expression values
	MExpN		<- matrix(0, nrow=nbN, ncol=1)			# Value of expression levels WITH noise
	MatDif		<- matrix(0, nrow=2, ncol=nbN*nbN)		# To measure euclidian distance
	Dists		<- array(0, dim=c(2, nbTrials, length(Levels)))		# 1st row : dist _O1, 2nd row : dist _O2 for each trial

	MatDif[1, ]	<- Sol									# First row : exact connectivity coefficients

	for (iLevel in 1:length(Levels)) {
		set.seed(12345)									# For reproducible results
		Sd	<- Levels[iLevel]*XMesNPMoy					# Noise standard deviation

		for (iTrial in 1:nbTrials) {
			Noise	<- matrix (rnorm(nbN, mean=0, sd=Sd), nrow=nbN)		# Non perturbed expression values ('Base'). Gaussian values, mean=0 standard dev=Sd
			MExpN	<- MatExp[ ,1] + Noise				# Value of expression levels WITH noise
			Pert_	<- "Base"							# Perturbation names, including replicas

			for (iRep in 1:nbRep) {
				Noise	<- matrix (rnorm(nbN*nbN*nbPert, mean=0, sd=Sd), nrow=nbN)
				MExpN	<- cbind(MExpN, MatExp[ ,2:(nbPert*nbN+1)] + Noise)
				Pert_	<- c(Pert_, Pert[2:(nbPert*nbN+1)])
			}

			MatDif[2, ]	<- MRARegress(MExpN, Pert_, Relative=FALSE, NoPrint=TRUE)$r
			Dists[1, iTrial, iLevel]	<- dist(MatDif)
			MatDif[2, ]	<- MRARegress(MExpN, Pert_, Method="Order2", Relative=FALSE, NoPrint=TRUE)$r
			Dists[2, iTrial, iLevel]	<- dist(MatDif)
		}
	}

	return (Dists)
}			# distMeasures

nbTrials	<- 20										# 	Number of trials
noiseLev	<- c(0.001, 0.003, 0.005, 0.007)			#	Variation coefficients of noise

#	Three kinases
Dists_3G	<- distMeasures (MExp_3_02_09_099, Pert_3_02_09_099, Solution_3G, 3, 2, 3, noiseLev, nbTrials)
for (iLevel in 1:length(noiseLev)) {
	vm1		<- mean (Dists_3G[1, ,iLevel])
	vm2		<- mean (Dists_3G[2, ,iLevel])
	cat ("k ", noiseLev[iLevel], " Mean dist. Order1 ", round(vm1,3), " Mean dist. Order2 ", round(vm2,3), "\n")
}
###		k  0.001  Mean dist. Order1  0.253  Mean dist. Order2  0.106 
###		k  0.003  Mean dist. Order1  0.253  Mean dist. Order2  0.227 
###		k  0.005  Mean dist. Order1  0.253  Mean dist. Order2  0.361 
###		k  0.007  Mean dist. Order1  0.254  Mean dist. Order2  0.508 

#	Four nodes
Dists_4G	<- distMeasures (MExp_4_02_09_099, Pert_4_02_09_099, Solution_4G, 4, 2, 3, noiseLev, nbTrials)
for (iLevel in 1:length(noiseLev)) {
	vm1		<- mean (Dists_4G[1, ,iLevel])
	vm2		<- mean (Dists_4G[2, ,iLevel])
	cat ("k ", noiseLev[iLevel], " Mean dist. Order1 ", round(vm1,3), " Mean dist. Order2 ", round(vm2,3), "\n")
}
###		k  0.001  Mean dist. Order1  0.615  Mean dist. Order2  0.199 
###		k  0.003  Mean dist. Order1  0.611  Mean dist. Order2  0.411 
###		k  0.005  Mean dist. Order1  0.608  Mean dist. Order2  0.568 
###		k  0.007  Mean dist. Order1  0.604  Mean dist. Order2  0.716

#	MAPK cascade (6 nodes)
Dists_6K	<- distMeasures (MExp_6_02_05_09_099_15, Pert_6_02_05_09_099_15, Solution_6K, 6, 2, 5, noiseLev, nbTrials)
for (iLevel in 1:length(noiseLev)) {
	vm1		<- mean (Dists_6K[1, ,iLevel])
	vm2		<- mean (Dists_6K[2, ,iLevel])
	cat ("k ", noiseLev[iLevel], " Mean dist. Order1 ", round(vm1,3), " Mean dist. Order2 ", round(vm2,3), "\n")
}
###		k  0.001  Mean dist. Order1  0.873  Mean dist. Order2  0.19 
###		k  0.003  Mean dist. Order1  0.877  Mean dist. Order2  0.455 
###		k  0.005  Mean dist. Order1  0.88  Mean dist. Order2  0.722 
###		k  0.007  Mean dist. Order1  0.888  Mean dist. Order2  0.974 


#
#	Figure 5
#	Mean values of the Distance to the diagonal of the networks from the "Dream Challenge 4" based on the percentage of known data
#

#
#	Tst_Knowledge_1	(for parallel computing)
#	This function calculates DC4 InSilico_10_xx and InSilico_100_xx network detection scores for 1 file and 1 knowledge level: "unit function".
#	nbD random draws of the position of the known data are made, unless this percentage is 0 or 100% in which case only 1 calculation is made.
#	Parameter : iCalc = (iFic-1)*nbPcKV + iKV

#	Parallel computing is necessary, because otherwise, the computation time would be very long
#	MRARegress, Score and Classify must be prefixed by the package name, otherwise they will not be recognized.

Tst_Knowledge_1		<- function (iCalc, Pert) {
	iFic	<-	(iCalc-1) %/% nbPcKV +1				# Index of the file studied
	iKV		<-	(iCalc-1) %%  nbPcKV +1				# Index of the KV percentage studied

	nbKV 	<- round(PcKV[iKV]*nbN*(nbN-1) / 100)	# Nbr of known values

	MatExp		<- matrix(nrow=nbN, ncol=nbK*nbN+1)		# Unitary matrices
	Solution	<- matrix(nrow=nbN, ncol=nbN)
	Result1		<- vector(length=nbD+1)					# To store unit results, plus last seed
	KnlM		<- matrix(nrow=nbN, ncol=nbN)			# The known values
	
	MatExp[ , ]		<- MatExpG[ ,((iFic-1)*(nbK*nbN+1)+1) : (iFic*(nbK*nbN+1))]
	Solution[ , ]	<- SolG	  [ ,((iFic-1)*nbN+1) 		  : (iFic*nbN)]

	if (nbKV == 0)	{								# Only one trial in this case
		Ret		<- MRARegress::MRARegress (MatExp, Pert, NoPrint=TRUE)
		Res		<- MRARegress::Score (MRARegress::Classify(Ret, NoPrint=TRUE), Solution, NoPrint=TRUE)$Scores2$Dst	

		for (iDraw in 1:nbD)
			Result1[iDraw]	<- Res
		Result1[nbD+1]	<- 0						# No seed value in this case
	} else if (nbKV == nbN*(nbN-1)) { 				# No trial in this case
		for (iDraw in 1:nbD)
			Result1[iDraw]	<- 1					# Every ri,j is known
		Result1[nbD+1]	<- 0						# No seed value in this case
	} else {
		set.seed(12345)								# To get the same sequence of random numbers
		for (iDraw in 1:nbD) {						# nbD simulations
			#	Choice of values to indicate to the program
			KnlM[ , ]	<- "x"
			if (nbKV > 0) {
				A	<- sample (NDiag, nbKV)	
				for (idx in A) {
					KnlM[idx]	<- ifelse(Solution[idx] == 1, 1, 0)
				}
			}
	
			Ret		<- MRARegress::MRARegress (MatExp, Pert, KnlgMap=KnlM, Hyp_Cvx=HCvx, NoPrint=TRUE)
			Res		<- MRARegress::Score (MRARegress::Classify(Ret, NoPrint=TRUE), Solution, NoPrint=TRUE)$Scores2$Dst

			Result1[iDraw]	<- Res
		}		# Loop on simulations (iDraw)
		Result1[nbD+1]	<-	.Random.seed			# To allow for further simulations, if necessary
	}

	return (Result1)
}		# Tst_Knowledge_1


PcKV		<- seq(0, 100, by=20)				# 	Percentage of known values
nbPcKV		<- length(PcKV)
HCvx		<- 0.5								#	KnlgMap\[i,j\] =  "1" means r\[i,j\] >=  HCvx
nbK			<- 2								#   nbK corresponds to the number of perturbation types (KO or KD)
nbD			<- 10								# 	Number of trials


#	Fig 5a
#	Mean and standard deviation for the 5 InSilico_10_1 to 5 networks, based on p (percentage of known coefficients)
#

nbN			<- 10								# 	Number of nodes
Fics		<- c("10_1", "10_2", "10_3", "10_4", "10_5")			# Files to study
nbFics		<- length(Fics)
Res.df		<- data.frame(pc=NULL, dd=NULL, ddP=NULL, ddM=NULL, Fic=NULL)	# 	To draw Figure "Dist to diagonal of the computed matrix = f(% known values)"
Result1G	<- matrix(0, nrow=nbD+1, ncol=nbFics*nbPcKV)			# To store unit results
Results		<- array(0, dim=c(2,nbPcKV,nbFics))						# To store averaged results
dimnames (Results)	<- list (c("Mean", "Std"), PcKV, Fics)
load (paste(vRoot, "Perturb_10.rda", sep=""))						# Perturb_10
MatExpG		<- matrix(0,   nrow=nbN, ncol=nbFics*(nbK*nbN+1))		# MatExp for all files
SolG		<- matrix(0,   nrow=nbN, ncol=nbFics*nbN)				# Solution for all files

Diag		<- NULL
for (i in 1:nbN) {
	Diag	<- cbind (Diag, (i-1)*nbN + i)		#	Position of the diagonal elements 
}
NDiag		<- seq (1, nbN*nbN, by=1)			# 	Index of terms not belonging to the diagonal
NDiag		<- NDiag[-Diag]

KnlM		<- matrix("x", nrow=nbN, ncol=nbN)	#	The known values

cat ("START 10 nodes networks !", as.character(Sys.time()), "\n")

for (iFic in 1:nbFics) {
	load (paste(vRoot, "MatExp_",   Fics[iFic], ".rda", sep=""))		#   MatExp
	load (paste(vRoot, "Solution_", Fics[iFic], ".rda", sep=""))		#   Solution

	MatExpG[ ,((iFic-1)*(nbK*nbN+1)+1) : (iFic*(nbK*nbN+1))]	<-	MatExp
	SolG[ 	 ,((iFic-1)*nbN+1)		   : (iFic*nbN)]			<-  Solution
}

Ncpus		<- parallel::detectCores()			# Number of cores : 20 in my PC
Ncpus		<- min(Ncpus, 15)					# To prevent the PC from overheating

cl			<- parallel::makeCluster(Ncpus)		# Start parallel computing
doParallel::registerDoParallel(cl)
Result1G	<- foreach (iCalc = 1:(nbFics*nbPcKV), .combine='cbind') %dopar% {
	Tst_Knowledge_1(iCalc, Perturb_10)
}
parallel::stopCluster(cl)

for(iFic in 1:nbFics) {
	for (iKV in 1:nbPcKV) {
		Results["Mean", iKV, iFic]		<- mean	(Result1G [1:nbD, (iFic-1)*nbPcKV+iKV])
		Results["Std",  iKV, iFic]		<- sd	(Result1G [1:nbD, (iFic-1)*nbPcKV+iKV])
		
		Res.tmp.df	<- data.frame(pc=PcKV[iKV], dd=Results["Mean",iKV,iFic], ddP=Results["Mean",iKV,iFic]+Results["Std",iKV,iFic], ddM=Results["Mean",iKV,iFic]-Results["Std",iKV,iFic], Fic=Fics[iFic])
		Res.df		<- rbind(Res.df, Res.tmp.df)		
	}		# Loop on percentage (iKV)
}			# Loop on Fics (iFic)

save(Results, file=paste(vRootFig, "Fig5a.rda", sep=""))
save(Res.df,  file=paste(vRootFig, "Fig5a_df.rda", sep=""))
save(Result1G, file=paste(vRootFig, "Fig5a_Result1G.rda", sep="")) 	# To allow for further simulations, if necessary

cat ("Done !", as.character(Sys.time()), "\n")

#	NomFic		<-	paste(vRootFig, "Fig5a_df.rda", sep="")		# in case of replay
#	load(NomFic)

NomFic 	<- paste(vRootFig, "Fig5a.pdf", sep="")
pdf(file=NomFic)
ggplot() +
	geom_line(data=Res.df, aes(x=pc, y=dd, colour=factor(Fic))) +
	xlim(0, 100) + ylim(0,1) +
	xlab("% known values") + ylab("Average distance to the diagonal") + ggtitle("Dist. to the diagonal, for the computed  matrix, InSilico_10_1 to 5") +
	scale_colour_manual(name="Fic", values=c("10_1"="blue", "10_2"="chartreuse1", "10_3"="brown3", "10_4"="darkgoldenrod3", "10_5"="gray7")) +
	theme(axis.text.x = element_text(color="black")) +
	theme(axis.text.y = element_text(color="black")) +
	theme(text = element_text(size = 10))
dev.off()

#	Now, open "Fig5a.pdf" with Inkscape, arrange the image (font size ...) and export it as . png 600 dpi

###		Results
###		, , 10_1
###		             0        20         40         60         80 100
###		Mean 0.7294118 0.7509804 0.82509804 0.87803922 0.92980392   1
###		Std  0.0000000 0.1009883 0.06356222 0.05327339 0.04892627   0
###		, , 10_2
###		             0         20         40         60         80 100
###		Mean 0.2797619 0.45982143 0.54791667 0.64136905 0.84880952   1
###		Std  0.0000000 0.07253945 0.06516657 0.09224857 0.06719427   0
###		, , 10_3
###		             0         20        40        60         80 100
###		Mean 0.4784314 0.49568627 0.5756863 0.7047059 0.86470588   1
###		Std  0.0000000 0.08182631 0.0890387 0.1354446 0.05368238   0
###		, , 10_4
###		             0        20         40         60         80 100
###		Mean 0.5313882 0.5886826 0.74244032 0.80150309 0.86410256   1
###		Std  0.0000000 0.1057423 0.08313951 0.08258308 0.05189502   0
###		, , 10_5
###		        0         20        40        60         80 100
###		Mean 0.25 0.38863636 0.5178030 0.6678030 0.85454545   1
###		Std  0.00 0.09040263 0.1150176 0.1184724 0.08545284   0


#	Fig 5b
#	Mean and standard deviation for the 5 InSilico_100_1 to 5 networks, based on p (percentage of known coefficients)
#

nbN			<- 100								# 	Number of nodes
Fics		<- c("100_1", "100_2", "100_3", "100_4", "100_5")			# Files to study
nbFics		<- length(Fics)
Res.df		<- data.frame(pc=NULL, dd=NULL, ddP=NULL, ddM=NULL, Fic=NULL)	# 	To draw Figure "Dist to diagonal of the computed matrix = f(% known values)"
Result1G	<- matrix(0, nrow=nbD+1, ncol=nbFics*nbPcKV)			# To store unit results
Results		<- array(0, dim=c(2,nbPcKV,nbFics))						# To store averaged results
dimnames (Results)	<- list (c("Mean", "Std"), PcKV, Fics)
load (paste(vRoot, "Perturb_100.rda", sep=""))						# Perturb_100
MatExpG		<- matrix(0,   nrow=nbN, ncol=nbFics*(nbK*nbN+1))		# MatExp for all files
SolG		<- matrix(0,   nrow=nbN, ncol=nbFics*nbN)				# Solution for all files

Diag		<- NULL
for (i in 1:nbN) {
	Diag	<- cbind (Diag, (i-1)*nbN + i)		#	Position of the diagonal elements 
}
NDiag		<- seq (1, nbN*nbN, by=1)			# 	Index of terms not belonging to the diagonal
NDiag		<- NDiag[-Diag]

KnlM		<- matrix("x", nrow=nbN, ncol=nbN)	#	The known values

cat ("START 100 nodes networks !", as.character(Sys.time()), "\n")

for (iFic in 1:nbFics) {
	load (paste(vRoot, "MatExp_",   Fics[iFic], ".rda", sep=""))		#   MatExp
	load (paste(vRoot, "Solution_", Fics[iFic], ".rda", sep=""))		#   Solution

	MatExpG[ ,((iFic-1)*(nbK*nbN+1)+1) : (iFic*(nbK*nbN+1))]	<-	MatExp
	SolG[ 	 ,((iFic-1)*nbN+1)		   : (iFic*nbN)]			<-  Solution
}

Ncpus		<- parallel::detectCores()			# Number of cores : 20 in my PC
Ncpus		<- min(Ncpus, 15)					# To prevent the PC from overheating

cl			<- parallel::makeCluster(Ncpus)		# Start parallel computing
doParallel::registerDoParallel(cl)
Result1G	<- foreach (iCalc = 1:(nbFics*nbPcKV), .combine='cbind') %dopar% {
	Tst_Knowledge_1(iCalc, Perturb_100)
}
parallel::stopCluster(cl)

for(iFic in 1:nbFics) {
	for (iKV in 1:nbPcKV) {
		Results["Mean", iKV, iFic]		<- mean	(Result1G [1:nbD, (iFic-1)*nbPcKV+iKV])
		Results["Std",  iKV, iFic]		<- sd	(Result1G [1:nbD, (iFic-1)*nbPcKV+iKV])
		
		Res.tmp.df	<- data.frame(pc=PcKV[iKV], dd=Results["Mean",iKV,iFic], ddP=Results["Mean",iKV,iFic]+Results["Std",iKV,iFic], ddM=Results["Mean",iKV,iFic]-Results["Std",iKV,iFic], Fic=Fics[iFic])
		Res.df		<- rbind(Res.df, Res.tmp.df)		
	}		# Loop on percentage (iKV)
}			# Loop on Fics (iFic)

save(Results, file=paste(vRootFig, "Fig5b.rda", sep=""))
save(Res.df,  file=paste(vRootFig, "Fig5b_df.rda", sep=""))
save(Result1G, file=paste(vRootFig, "Fig5b_Result1G.rda", sep="")) 	# To allow for further simulations, if necessary

cat ("Done !", as.character(Sys.time()), "\n")					# Length of processing : 2h. 45 min.

#	NomFic		<-	paste(vRootFig, "Fig5b_df.rda", sep="")		# in case of replay
#	load(NomFic)

NomFic 	<- paste(vRootFig, "Fig5b.pdf", sep="")
pdf(file=NomFic)
ggplot() +
	geom_line(data=Res.df, aes(x=pc, y=dd, colour=factor(Fic))) +
	xlim(0, 100) + ylim(0,1) +
	xlab("% known values") + ylab("Average distance to the diagonal") + ggtitle("Dist. to the diagonal, for the computed  matrix, InSilico_100_1 to 5") +
	scale_colour_manual(name="Fic", values=c("100_1"="blue", "100_2"="chartreuse1", "100_3"="brown3", "100_4"="darkgoldenrod3", "100_5"="gray7")) +		
	theme(axis.text.x = element_text(color="black")) +
	theme(axis.text.y = element_text(color="black")) +
	theme(text = element_text(size = 10))
dev.off()

#	Now, open "Fig5b.pdf" with Inkscape, arrange the image (font size ...) and export it as . png 600 dpi

print (Results)
###		, , 100_1
###		             0         20         40         60         80 100
###		Mean 0.2177876 0.44045103 0.65478513 0.80744836 0.89606529   1
###		Std  0.0000000 0.05053866 0.03958012 0.02550041 0.02552004   0
###		, , 100_2
###		             0         20         40         60         80 100
###		Mean 0.2072769 0.41156780 0.56544698 0.73563745 0.86209624   1
###		Std  0.0000000 0.03230744 0.03023583 0.01788937 0.02182067   0
###		, , 100_3
###		             0         20         40         60         80 100
###		Mean 0.2632984 0.40593209 0.59553446 0.72315015 0.86597811   1
###		Std  0.0000000 0.05098897 0.04202984 0.03350927 0.01909741   0
###		, , 100_4
###		             0         20         40         60        80 100
###		Mean 0.3050072 0.44310680 0.57808329 0.71564480 0.8675315   1
###		Std  0.0000000 0.03016249 0.02497073 0.01663264 0.0230875   0
###		, , 100_5
###		            0         20         40         60        80 100
###		Mean 0.171769 0.29714902 0.48236197 0.64626261 0.7605664   1
###		Std  0.000000 0.03048871 0.04429216 0.03936533 0.2438183   0


#
#	Table in S.I. (Supplementary table 1)
#	Standard deviation of diagonal distances from DC4 networks, depending on the percentage of known data (10 simulations each time)
#

load (paste(vRootFig, "Fig5a.rda", sep=""))			#	Run the code for Fig 5a first
print (Results)
load (paste(vRootFig, "Fig5b.rda", sep=""))			#	Run the code for Fig 5b first
print (Results)


#
#	Figure 6
#	Average distance between solutions and calculated matrices, FRANK generated networks (30, 60, 100 nodes), 
#	based on percentage of known data and noise level	(ribbon : ± standard deviation)
#

#	Tst_Knowledge_2
#	This function calculates FRANK network detection scores, for all files in a TF/TA file set and a level of knowledge: "unit function".
#	nbD random draws of the position of the known data are made, unless this percentage is 0 or 100% in which case only 1 calculation is made.
#	Parameter : iCalc = (iFic-1)*nbPcKV + iKV
#

#	Parallel computing is necessary, because otherwise, the computation time would be very long
#	MRARegress, Score and Classify must be prefixed by the package name, otherwise they will not be recognized.
#

Tst_Knowledge_2		<- function (iCalc) {
	iFic	<-	(iCalc-1) %/% nbPcKV +1				# Index of the file studied
	iKV		<-	(iCalc-1) %%  nbPcKV +1				# Index of the KV percentage studied

	nbKV 	<- round(PcKV[iKV]*nbN*(nbN-1) / 100)	# Nbr of known values

	MatExp		<- matrix(nrow=nbN, ncol=nbK*nbN+1)	# Unitary matrices
	Solution	<- matrix(nrow=nbN, ncol=nbN)
	Result1		<- vector(length=nbD+1)				# To store unit results, plus last seed
	KnlM		<- matrix(nrow=nbN, ncol=nbN)		# The known values
	MatDif		<- matrix(nrow=2, ncol=nbN*nbN)		# To compute the score
	
	MatExp[ , ]		<- MatExpG[ , ,iFic,iT]
	Solution[ , ]	<- SolG	  [ , ,iFic]
	MatDif[1, ]		<- Solution[ , ]

	if (nbKV == 0)	{								# Only one trial in this case
		Ret		<- MRARegress::MRARegress (MatExp, PertG, NoPrint=TRUE)
		MatDif[2, ]	<- Ret$r	
		for (iDraw in 1:nbD)
			Result1[iDraw]	<- dist(MatDif)
		Result1[nbD+1]	<- 0						# No seed value in this case
	} else if (nbKV == nbN*(nbN-1)) { 				# No trial in this case
		for (iDraw in 1:nbD)
			Result1[iDraw]	<- 0					# Every ri,j is known
		Result1[nbD+1]	<- 0						# No seed value in this case
	} else {
		set.seed(12345)								#	To get the same sequence of random numbers
		for (iDraw in 1:nbD) {						# 	nbD simulations
			#	Choice of the values to be indicated to the program
			KnlM[ , ]	<- "x"
			if (nbKV > 0) {
				A	<- sample (NDiag, nbKV)	
				for (idx in A) {
					if (Solution[idx] > 0)
						KnlM[idx]	<- 1
					else if (Solution[idx] < 0)
						KnlM[idx]	<- -1
					else
						KnlM[idx]	<- 0
				}
			}
	
			Ret		<- MRARegress::MRARegress (MatExp, PertG, KnlgMap=KnlM, Hyp_Cvx=HCvx, NoPrint=TRUE)
			MatDif[2, ]	<- Ret$r	
			Result1[iDraw]	<- dist(MatDif)
		}		# Loop on simulations (iDraw)
		Result1[nbD+1]	<-	.Random.seed			# To allow for further simulations, if necessary
	}

	return (Result1)
}		# Tst_Knowledge_2


#	The original data delivered by FRANK Network Generator are archived, in case more computations are needed. Files are named ""Frankxxxxnonmodified_network.csv",
#	where xxxx are :
#	  11,  649, 8363, 5883, 6798	for TF=30,   TA=0, (z = 1,2 ..5 and Seed = Seeds[z]), 	Set = 1
#	4685, 3537, 1797, 7380, 2568	for TF=60,   TA=0,										Set = 2
#	9725, 9163, 2648, 9991, 8602	for TF=100,  TA=0,										Set = 3

Sets		<-	c(1, 2, 3)
nbSets		<- length(Sets)
nbFics		<-  5				# Nbr of files by set of values
nbK			<-	2				# Nbr of perturbations (KO, KD -50%)
nbD			<- 10				# Number of trials

Noises		<- c(0.1, 0.5)		# Error coefficients
nbT			<- length(Noises)

#	PcKV		<- seq(0, 100, by=20)							# Percentage of known values
PcKV		<- c(0, 20, 40, 60, 70, 75, 80, 85, 90, 100)	# Percentage of known values
nbPcKV		<- length(PcKV)
HCvx		<- 0.1											# KnlgMap\[i,j\] =  "1" means r\[i,j\] >=  HCvx			vs 0.5

Result1G	<- array(0, dim=c(nbD+1, nbPcKV, nbSets, nbFics, nbT))		# To store unit results
Results		<- array(0, dim=c(2, 	 nbPcKV, nbSets, nbT))				# To store averaged results
dimnames (Results)	<- list (c("Mean", "Std"), PcKV, Sets, Noises)

Res.df		<- data.frame(pc=NULL, dd=NULL, ddP=NULL, ddM=NULL, Set=NULL, Noise=NULL)	# To draw Figure "Euclidian Distance between computed matrix and solution = f(% known values)"

val			<- paste(vRoot, "FileNbr.csv", sep="")
FileNbr		<- as.matrix(fread(val, data.table=F, header=T), ncol=nbFics+2)
					# Column name	: TF 	TA    1 	 2 	   3 	 4 	   5
					# First row		: Seed	 	12345 72090 87577 45648 16637
					# Following rows: TF val TA val File nbrs

Ncpus		<- parallel::detectCores()			# Number of cores : 20 in my PC
Ncpus		<- min(Ncpus, 15)					# To prevent the PC from overheating

cat ("START FRANK networks !", as.character(Sys.time()), "\n")

for (iSet in 1:nbSets) {
	Set			<- Sets[iSet]
	TF			<- as.numeric(FileNbr[Set, 1])
	TA			<- as.numeric(FileNbr[Set, 2])
	nbN			<- TF+TA

	MatExpG		<- array(0, dim=c(nbN, nbK*nbN+1, nbFics, nbT))		# MatExp, for all files of the set
	SolG		<- array(0, dim=c(nbN, nbN, nbFics))					# Solution, for all files of the set
	PertG		<- vector(length=nbK*nbN+1)								# Perturbation, for all files of the set

	Diag		<- NULL
	for (i in 1:nbN) {
		Diag	<- cbind (Diag, (i-1)*nbN + i)				# Position of the diagonal elements 
	}
	NDiag		<- seq (1, nbN*nbN, by=1)					# Index of terms not belonging to the diagonal
	NDiag		<- NDiag[-Diag]

	for (iFic in 1:nbFics) {
		valR	<- paste(vRoot, "Frank_TF", TF, "_TA", TA, "_", iFic, "_Sol.rda", sep="")
		
		load (valR)				# Solution
		SolG[ , ,iFic]				<-  Solution

		for (iT in 1:nbT) {
			valR	<- paste(vRoot, "Frank_TF", TF, "_TA", TA, "_", iFic, "_R", iT, ".rda", sep="")
			load (valR)				# MatRN2
			Res		<- MatR2MatExp	(MatRN2, nbN, nbK)		# software utility, to get the data in the format expected by MRARegress
			MatExpG[ , ,iFic,iT]	<- Res$Exp
			PertG  					<- Res$Pert				# PertG doesn't depend on iT or iFic (not useful to use an array)
		}	# Loop iT
	}		# loop iFic

	for (iT in 1:nbT)	{
		cat (" Set TF ", TF, " TA ", TA, " Noise ", Noises[iT]," at : ", as.character(Sys.time()), "\n")
		
		cl	<- parallel::makeCluster(Ncpus)		# Start parallel computing
		doParallel::registerDoParallel(cl)
		Result1G[ , ,iSet, ,iT]		<- foreach (iCalc = 1:(nbFics*nbPcKV), .combine='cbind') %dopar% {
			Tst_Knowledge_2(iCalc)
		}
		parallel::stopCluster(cl)

		for (iKV in 1:nbPcKV) {
			Results["Mean",iKV,iSet,iT]		<- mean	(Result1G [1:nbD,iKV,iSet, ,iT])
			Results["Std", iKV,iSet,iT]		<- sd	(Result1G [1:nbD,iKV,iSet, ,iT])
			
			moy		<- Results["Mean",iKV,iSet,iT]
			std		<- Results["Std", iKV,iSet,iT]
			Res.tmp.df	<- data.frame(pc=PcKV[iKV], dd=moy, ddP=moy+std, ddM=moy-std, Set=Sets[iSet], Noise=iT)
			Res.df		<- rbind(Res.df, Res.tmp.df)		
		}		# Loop on percentage (iKV)
	}			# Loop iT
}				# loop iSet

save(Results, file=paste(vRootFig, "Fig6.rda", sep=""))
save(Res.df,  file=paste(vRootFig, "Fig6_df.rda", sep=""))
save(Result1G, file=paste(vRootFig, "Fig6_Result1G.rda", sep="")) 	# To allow for further simulations, if necessary

cat ("Done !", as.character(Sys.time()), "\n")			# Length of processing : 7 hours

#	NomFic		<-	paste(vRootFig, "Fig6_df.rda", sep="")		# in case of replay
#	load(NomFic)

#
#	Figure 6a	(k=0.1 : medium noise  -- Gaussian noise N(0,sd), with sd = 0.1* mean(abs(MatR))
#

NomFic 		<- paste(vRootFig, "Fig6a.pdf", sep="")
Res1.df		<- subset(Res.df, Noise == 1)
Res1_1.df	<- subset(Res1.df, Set == 1)			# TF30,  TA0
Res1_2.df	<- subset(Res1.df, Set == 2)			# TF60,  TA0
Res1_3.df	<- subset(Res1.df, Set == 3)			# TF100, TA0

pdf(file=NomFic)
ggplot(data=Res1.df) +
	geom_line(aes(x=pc, y=dd, colour=factor(Set))) + geom_point(aes(x=pc, y=dd, colour=factor(Set))) +
	xlab("% known values") + ylab("Average distance between Solution and Calculated Matrix") + ggtitle("Dist. between Solution and Calculated Matrix : \nFRANK  TF = 30, 60, 100, TA = 0, medium noise (k = 0.1)") +
	scale_colour_manual(name="Set", values=c("1"="blue", "2"="chartreuse1", "3"="brown3")) +
	geom_ribbon(data=Res1_1.df, aes(x=pc, ymin=ddM, ymax=ddP), fill="cadetblue1", 		alpha=0.3) +		# Ribbon around a "blue" line
	geom_ribbon(data=Res1_2.df, aes(x=pc, ymin=ddM, ymax=ddP), fill="darkolivegreen3", alpha=0.3) +		# Ribbon around a "chartreuse1" line
	geom_ribbon(data=Res1_3.df, aes(x=pc, ymin=ddM, ymax=ddP), fill="chocolate1", 		alpha=0.3) +		# Ribbon around a "brown3" line
	theme(axis.text.x = element_text(color="black")) +
	theme(axis.text.y = element_text(color="black")) +
	theme(text = element_text(size = 10))
dev.off()


#	Now, open "Fig6a.pdf" with Inkscape, arrange the image (font size ...) and export it as . png 600 dpi


#
#	Figure 6b	(k=0.5 : strong noise  -- Gaussian noise N(0,sd), with sd = 0.5* mean(abs(MatR))
#

NomFic 		<- paste(vRootFig, "Fig6b.pdf", sep="")
Res2.df		<- subset(Res.df, Noise == 2)
Res2_1.df	<- subset(Res2.df, Set == 1)			# TF30,  TA0
Res2_2.df	<- subset(Res2.df, Set == 2)			# TF60,  TA0
Res2_3.df	<- subset(Res2.df, Set == 3)			# TF100, TA0

pdf(file=NomFic)
ggplot(data=Res2.df) +
	geom_line(aes(x=pc, y=dd, colour=factor(Set))) + geom_point(aes(x=pc, y=dd, colour=factor(Set))) +
	xlab("% known values") + ylab("Average distance between Solution and Calculated Matrix") + ggtitle("Dist. between Solution and Calculated Matrix : \nFRANK  TF = 30, 60, 100, TA = 0, strong noise (k = 0.5)") +
	scale_colour_manual(name="Set", values=c("1"="blue", "2"="chartreuse1", "3"="brown3")) +
	geom_ribbon(data=Res2_1.df, aes(x=pc, ymin=ddM, ymax=ddP), fill="cadetblue1", 		alpha=0.3) +		# Ribbon around a "blue" line
	geom_ribbon(data=Res2_2.df, aes(x=pc, ymin=ddM, ymax=ddP), fill="darkolivegreen3", alpha=0.3) +		# Ribbon around a "chartreuse1" line
	geom_ribbon(data=Res2_3.df, aes(x=pc, ymin=ddM, ymax=ddP), fill="chocolate1", 		alpha=0.3) +		# Ribbon around a "brown3" line
	theme(axis.text.x = element_text(color="black")) +
	theme(axis.text.y = element_text(color="black")) +
	theme(text = element_text(size = 10))
dev.off()

#	Now, open "Fig6b.pdf" with Inkscape, arrange the image (font size ...) and export it as . png 600 dpi

print (Results)			# HCvx = 0.1
###		, , 1, 0.1
###		              0         20         40         60         70         75        80         85         90 100
###		Mean 0.53807802 0.47931241 0.42105042 0.36076668 0.33247764 0.31488497 0.3017738 0.28448718 0.26918802   0
###		Std  0.08544347 0.07402877 0.05671406 0.04687009 0.04055174 0.03070697 0.0337981 0.02930777 0.02995866   0
###		
###		, , 2, 0.1
###		             0        20        40         60         70         75         80         85         90 100
###		Mean 1.0353508 0.9049661 0.7676512 0.62839205 0.55601017 0.52201204 0.48523493 0.44878167 0.40801018   0
###		Std  0.1908226 0.1543061 0.1188528 0.09210166 0.08235533 0.08405417 0.08504167 0.08811403 0.09344986   0
###		
###		, , 3, 0.1
###		             0        20        40         60         70         75         80         85         90 100
###		Mean 1.4007063 1.2159082 1.0310414 0.84351896 0.74642371 0.69860734 0.65077541 0.60270061 0.55086317   0
###		Std  0.2426198 0.1921912 0.1415155 0.08545041 0.05557987 0.04096395 0.02780376 0.01807879 0.02133163   0
###		
###		, , 1, 0.5
###		             0        20        40        60        70       75        80        85        90 100
###		Mean 2.5157277 2.2024860 1.9067644 1.6085473 1.4637924 1.393486 1.3314153 1.2514910 1.1793241   0
###		Std  0.4109394 0.3443972 0.2604825 0.2141473 0.1881081 0.166817 0.1614541 0.1352178 0.1308682   0
###		
###		, , 2, 0.5
###		             0        20        40        60        70        75        80        85        90 100
###		Mean 4.5994789 3.9926712 3.3858568 2.7931957 2.4956462 2.3483971 2.1906105 2.0385159 1.8787370   0
###		Std  0.7315105 0.6155399 0.5076789 0.4252225 0.3637757 0.3612954 0.3289608 0.3136359 0.2898417   0
###		
###		, , 3, 0.5
###		             0        20       40        60        70        75        80       85        90 100
###		Mean 6.2720540 5.3615645 4.507470 3.6680857 3.2451102 3.0335027 2.8150817 2.601215 2.3601429   0
###		Std  0.8457015 0.7125749 0.606942 0.5063534 0.4631001 0.4361872 0.4060037 0.383213 0.3351266   0


#
#	SI_Figure 3
#	Average distance between solutions and calculated matrices, FRANK generated networks (60, 100, 200 nodes, including 50% of non-regulating genes)
#	based on the percentage of known non-regulating genes and noise level 	(ribbon : ± standard deviation)
#

#	Tst_Knowledge_3
#	This function calculates FRANK network detection scores, for all files in a TF/TA file set and a level of knowledge: "unit function".
#	nbD tirages aleatoires de la position des noeuds non régulants connus sont réalisées, sauf si ce pourcentage vaut 0 auqiel cas 1 seul calcul est effectué.
#	nbD random draws of the position of known non-regulating nodes are performed, unless this percentage is 0 or 100% in which case only 1 calculation is made.
#	Parameter : iCalc = (iFic-1)*nbPcKV + iKV
#

#	Parallel computing is necessary, because otherwise, the computation time would be very long
#	MRARegress, Score and Classify must be prefixed by the package name, otherwise they will not be recognized.
#

Tst_Knowledge_3		<- function (iCalc) {
	iFic	<-	(iCalc-1) %/% nbPcKV +1				# Index of the file studied
	iKV		<-	(iCalc-1) %%  nbPcKV +1				# Index of the KV percentage studied

	nbKV 	<- round(PcKV[iKV]*TA / 100)			# Nbr of known nodes

	MatExp		<- matrix(nrow=nbN, ncol=nbK*nbN+1)	# Unitary matrices
	Solution	<- matrix(nrow=nbN, ncol=nbN)
	Result1		<- vector(length=nbD+1)				# To store unit results, plus last seed
	KnlM		<- matrix(nrow=nbN, ncol=nbN)		# The known values
	MatDif		<- matrix(nrow=2, ncol=nbN*nbN)		# To compute the score
	
	MatExp[ , ]		<- MatExpG[ , ,iFic,iT]
	Solution[ , ]	<- SolG	  [ , ,iFic]
	MatDif[1, ]		<- Solution[ , ]

	if (nbKV == 0)	{								# Only one trial in this case
		Ret		<- MRARegress::MRARegress (MatExp, PertG, NoPrint=TRUE)
		MatDif[2, ]	<- Ret$r	
		for (iDraw in 1:nbD)
			Result1[iDraw]	<- dist(MatDif)
		Result1[nbD+1]	<- 0						# No seed value in this case
	} else {
		set.seed(12345)								#	To get the same sequence of random numbers
		for (iDraw in 1:nbD) {						# 	nbD simulations
			#	Choice of the nodes to be indicated to the program
			KnlM[ , ]	<- "x"
			A	<- sample (1:TA, nbKV)	
			for (idx in A) {
				KnlM[ ,TF+idx]	<- 0
			}
	
			Ret		<- MRARegress::MRARegress (MatExp, PertG, KnlgMap=KnlM, Hyp_Cvx=HCvx, NoPrint=TRUE)
			MatDif[2, ]	<- Ret$r	
			Result1[iDraw]	<- dist(MatDif)
		}		# Loop on simulations (iDraw)
		Result1[nbD+1]	<-	.Random.seed			# To allow for further simulations, if necessary
	}

	return (Result1)
}		# Tst_Knowledge_3


#	The original data delivered by FRANK Network Generator are archived, in case more computations are needed. Files are named ""Frankxxxxnonmodified_network.csv",
#	where xxxx are :
#	5191, 5303, 3890, 9658, 5309	for TF=30,   TA=30,			Set = 9
#	7120, 8664,  239, 3835, 4999	for TF=50,	 TA=50,			Set = 10
#	1276, 3865, 7672, 2237, 7584	for TF=100,  TA=100,		Set = 11

Sets		<-	c(9, 10, 11)
nbSets		<- length(Sets)
nbFics		<-  5				# Nbr of files by set of values
nbK			<-	2				# Nbr of perturbations (KO, KD -50%)
nbD			<- 10				# Number of trials

Noises		<- c(0.1, 0.5)		# Error coefficients
nbT			<- length(Noises)

PcKV		<- seq(0, 100, by=20)							# Percentage of known TA nodes
nbPcKV		<- length(PcKV)
HCvx		<- 0.1											# KnlgMap\[i,j\] =  "1" means r\[i,j\] >=  HCvx  -- not used here

Result1G	<- array(0, dim=c(nbD+1, nbPcKV, nbSets, nbFics, nbT))		# To store unit results
Results		<- array(0, dim=c(2, 	 nbPcKV, nbSets, nbT))				# To store averaged results
dimnames (Results)	<- list (c("Mean", "Std"), PcKV, Sets, Noises)

Res.df		<- data.frame(pc=NULL, dd=NULL, ddP=NULL, ddM=NULL, Set=NULL, Noise=NULL)	# To draw Figure "Euclidian Distance between computed matrix and solution = f(% known TA nodes)"

val			<- paste(vRoot, "FileNbr.csv", sep="")
FileNbr		<- as.matrix(fread(val, data.table=F, header=T), ncol=nbFics+2)
					# Column name	: TF 	TA    1 	 2 	   3 	 4 	   5
					# First row		: Seed	 	12345 72090 87577 45648 16637
					# Following rows: TF val TA val File nbrs

Ncpus		<- parallel::detectCores()			# Number of cores : 20 in my PC
Ncpus		<- min(Ncpus, 15)					# To prevent the PC from overheating

cat ("START FRANK networks !", as.character(Sys.time()), "\n")

for (iSet in 1:nbSets) {
	Set			<- Sets[iSet]
	TF			<- as.numeric(FileNbr[Set, 1])
	TA			<- as.numeric(FileNbr[Set, 2])
	nbN			<- TF+TA

	MatExpG		<- array(0, dim=c(nbN, nbK*nbN+1, nbFics, nbT))		# MatExp, for all files of the set
	SolG		<- array(0, dim=c(nbN, nbN, nbFics))					# Solution, for all files of the set
	PertG		<- vector(length=nbK*nbN+1)								# Perturbation, for all files of the set

	for (iFic in 1:nbFics) {
		valR	<- paste(vRoot, "Frank_TF", TF, "_TA", TA, "_", iFic, "_Sol.rda", sep="")
		load (valR)				# Solution
		SolG[ , ,iFic]				<-  Solution

		for (iT in 1:nbT) {
			valR	<- paste(vRoot, "Frank_TF", TF, "_TA", TA, "_", iFic, "_R", iT, ".rda", sep="")
			load (valR)				# MatRN2
			Res		<- MatR2MatExp	(MatRN2, nbN, nbK)		# software utility, to get the data in the format expected by MRARegress
			MatExpG[ , ,iFic,iT]	<- Res$Exp
			PertG  					<- Res$Pert				# PertG doesn't depend on iT or iFic (not useful to use an array)
		}	# Loop iT
	}		# loop iFic

	for (iT in 1:nbT)	{
		cat (" Set TF ", TF, " TA ", TA, " Noise ", Noises[iT]," at : ", as.character(Sys.time()), "\n")
		
		cl	<- parallel::makeCluster(Ncpus)		# Start parallel computing
		doParallel::registerDoParallel(cl)
		Result1G[ , ,iSet, ,iT]		<- foreach (iCalc = 1:(nbFics*nbPcKV), .combine='cbind') %dopar% {
			Tst_Knowledge_3(iCalc)
		}
		parallel::stopCluster(cl)

		for (iKV in 1:nbPcKV) {
			Results["Mean",iKV,iSet,iT]		<- mean	(Result1G [1:nbD,iKV,iSet, ,iT])
			Results["Std", iKV,iSet,iT]		<- sd	(Result1G [1:nbD,iKV,iSet, ,iT])
			
			moy		<- Results["Mean",iKV,iSet,iT]
			std		<- Results["Std", iKV,iSet,iT]
			Res.tmp.df	<- data.frame(pc=PcKV[iKV], dd=moy, ddP=moy+std, ddM=moy-std, Set=Sets[iSet], Noise=iT)
			Res.df		<- rbind(Res.df, Res.tmp.df)		
		}		# Loop on percentage (iKV)
	}			# Loop iT
}				# loop iSet

save(Results, file=paste(vRootFig, "SI_Fig3.rda", sep=""))
save(Res.df,  file=paste(vRootFig, "SI_Fig3_df.rda", sep=""))
save(Result1G, file=paste(vRootFig, "SI_Fig3_Result1G.rda", sep="")) 	# To allow for further simulations, if necessary

cat ("Done !", as.character(Sys.time()), "\n")			# Length of processing : 19 hours

#	NomFic		<-	paste(vRootFig, "SI_Fig3_df.rda", sep="")		# in case of replay
#	load(NomFic)

#
#	SI_Figure 3a	(k=0.1 : medium noise  -- Gaussian noise N(0,sd), with sd = 0.1* mean(abs(MatR))
#
NomFic 		<- paste(vRootFig, "SI_Fig3a.pdf", sep="")
Res1.df		<- subset(Res.df, Noise == 1)
Res1_1.df	<- subset(Res1.df, Set == 9)			# TF30,  TA30
Res1_2.df	<- subset(Res1.df, Set == 10)			# TF50,  TA50
Res1_3.df	<- subset(Res1.df, Set == 11)			# TF100, TA100

pdf(file=NomFic)
ggplot(data=Res1.df) +
	geom_line(aes(x=pc, y=dd, colour=factor(Set))) + geom_point(aes(x=pc, y=dd, colour=factor(Set))) +
	xlab("% known TA nodes") + ylab("Average distance between Solution and Calculated Matrix") + ggtitle("Dist. between Solution and Calculated Matrix : \nFRANK  TA = TF = 30, 50, 100, medium noise (k = 0.1)") +
	scale_colour_manual(name="Set", values=c("9"="blue", "10"="chartreuse1", "11"="brown3")) +
	geom_ribbon(data=Res1_1.df, aes(x=pc, ymin=ddM, ymax=ddP), fill="cadetblue1", 		alpha=0.3) +		# Ribbon around a "blue" line
	geom_ribbon(data=Res1_2.df, aes(x=pc, ymin=ddM, ymax=ddP), fill="darkolivegreen3", alpha=0.3) +		# Ribbon around a "chartreuse1" line
	geom_ribbon(data=Res1_3.df, aes(x=pc, ymin=ddM, ymax=ddP), fill="chocolate1", 		alpha=0.3) +		# Ribbon around a "brown3" line
	theme(axis.text.x = element_text(color="black")) +
	theme(axis.text.y = element_text(color="black")) +
	theme(text = element_text(size = 10))
dev.off()

#	Now, open "SI_Fig3a.pdf" with Inkscape, arrange the image (font size ...) and export it as . png 600 dpi


#
#	SI_Figure 3b	(k=0.5 : strong noise  -- Gaussian noise N(0,sd), with sd = 0.5* mean(abs(MatR))
#
NomFic 		<- paste(vRootFig, "SI_Fig3b.pdf", sep="")
Res2.df		<- subset(Res.df, Noise == 2)
Res2_1.df	<- subset(Res2.df, Set == 9)			# TF30,  TA30
Res2_2.df	<- subset(Res2.df, Set == 10)			# TF50,  TA50
Res2_3.df	<- subset(Res2.df, Set == 11)			# TF100, TA100

pdf(file=NomFic)
ggplot(data=Res2.df) +
	geom_line(aes(x=pc, y=dd, colour=factor(Set))) + geom_point(aes(x=pc, y=dd, colour=factor(Set))) +
	xlab("% known TA nodes") + ylab("Average distance between Solution and Calculated Matrix") + ggtitle("Dist. between Solution and Calculated Matrix : \nFRANK  TA = TF = 30, 50, 100, strong noise (k = 0.5)") +
	scale_colour_manual(name="Set", values=c("9"="blue", "10"="chartreuse1", "11"="brown3")) +
	geom_ribbon(data=Res2_1.df, aes(x=pc, ymin=ddM, ymax=ddP), fill="cadetblue1", 		alpha=0.3) +		# Ribbon around a "blue" line
	geom_ribbon(data=Res2_2.df, aes(x=pc, ymin=ddM, ymax=ddP), fill="darkolivegreen3", alpha=0.3) +		# Ribbon around a "chartreuse1" line
	geom_ribbon(data=Res2_3.df, aes(x=pc, ymin=ddM, ymax=ddP), fill="chocolate1", 		alpha=0.3) +		# Ribbon around a "brown3" line
	theme(axis.text.x = element_text(color="black")) +
	theme(axis.text.y = element_text(color="black")) +
	theme(text = element_text(size = 10))
dev.off()

#	Now, open "SI_Fig3b.pdf" with Inkscape, arrange the image (font size ...) and export it as . png 600 dpi

print (Results)
###		, , 9, 0.1
###		             0        20        40        60        80       100
###		Mean 0.5303509 0.5068354 0.4805305 0.4549584 0.4266633 0.3964758
###		Std  0.1904786 0.1828465 0.1713287 0.1642622 0.1524940 0.1412048
###		
###		, , 10, 0.1
###		             0        20        40        60        80       100
###		Mean 0.8634885 0.8239871 0.7820247 0.7375116 0.6917442 0.6413673
###		Std  0.3613576 0.3423218 0.3230332 0.3015359 0.2817506 0.2571711
###		
###		, , 11, 0.1
###		             0        20        40        60        80       100
###		Mean 1.2845757 1.2262475 1.1646994 1.0993714 1.0309847 0.9571347
###		Std  0.2201866 0.2070006 0.1935311 0.1784567 0.1634537 0.1450326
###		
###		, , 9, 0.5
###		             0        20        40        60        80       100
###		Mean 2.5834857 2.4598463 2.3342893 2.2076608 2.0785491 1.9416684
###		Std  0.8502769 0.8147785 0.7709441 0.7397709 0.7027575 0.6640493
###		
###		, , 10, 0.5
###		            0       20       40       60       80      100
###		Mean 4.135217 3.937801 3.736865 3.527573 3.322577 3.095112
###		Std  1.610977 1.522536 1.443693 1.352630 1.278053 1.183553
###		
###		, , 11, 0.5
###		             0        20        40        60        80       100
###		Mean 6.1980290 5.8940775 5.5902211 5.2746109 4.9580340 4.6316215
###		Std  0.9821818 0.9207651 0.8611084 0.7961224 0.7244947 0.6506125


#
#	Unit tests
#
library(MRARegress)
library(testthat)
library(stringr)
library(glmnet)
library(minet)
library(randomForest)
library(CVXR)
library(broom)
library(stats)
library(dplyr)
library(magrittr)
library(rootSolve)
library(RCy3)
library(RColorBrewer)
library(pheatmap)
library(ggplot2)
library(covr)

covr	<-	file_coverage("R/MRARegress.R", "tests/testthat/test_MRARegress.R")
print (covr)
###		Coverage: 94.44%
###		R/MRARegress.R: 94.44%

covr	<-	file_coverage("R/Classify.R", "tests/testthat/test_Classify.R")
print (covr)
###		Coverage: 90.45%
###		R/Classify.R: 90.45%

covr	<-	file_coverage("R/DrawDiscr.R", "tests/testthat/test_DrawDiscr.R")
print (covr)
###		Coverage: 92.98%
###		R/DrawDiscr.R: 92.98%

covr	<-	file_coverage("R/DrawGraph.R", "tests/testthat/test_DrawGraph.R")
print (covr)
###		Coverage: 91.11%
###		R/DrawGraph.R: 91.11%

covr	<-	file_coverage("R/DrawGraphML.R", "tests/testthat/test_DrawGraphML.R")
print (covr)
###		Coverage: 91.72%
###		R/DrawGraphML.R: 91.72%

covr	<-	file_coverage("R/DrawHeat.R", "tests/testthat/test_DrawHeat.R")
print (covr)
###		Coverage: 93.44%
###		R/DrawHeat.R: 93.44%

covr	<-	file_coverage("R/rCI.R", "tests/testthat/test_rCI.R")
print (covr)
###		Coverage: 90.12%
###		R/rCI.R: 90.12%

covr	<-	file_coverage("R/Score.R", "tests/testthat/test_Score.R")
print (covr)
###		Coverage: 87.69%
###		R/Score.R: 87.69%

covrMoy	<-	mean(c(0.9444, 0.9045, 0.9288, 0.9111, 0.9172, 0.9344, 0.9012, 0.8769))
#	0.9148125
